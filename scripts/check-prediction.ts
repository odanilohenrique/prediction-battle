// Script to check prediction state on-chain
// Run with: npx ts-node scripts/check-prediction.ts

import { createPublicClient, http, parseAbi } from 'viem';
import { baseSepolia } from 'viem/chains';
import * as dotenv from 'dotenv';

dotenv.config({ path: '.env.local' });

const CONTRACT_ADDRESS = '0x3df1475c9cb9dfb469d9ade86d3d3c41ac9984f7';
const PREDICTION_ID = 'pred_1768325169545_ztc8bo9';

const ABI = parseAbi([
    'struct Prediction { string id; uint256 target; uint256 deadline; bool resolved; bool result; uint256 totalYes; uint256 totalNo; address[] yesBettors; address[] noBettors; bool isVoid; uint256 processedIndex; bool paidOut; address creator; uint256 seedYes; uint256 seedNo; }',
    'function predictions(string) view returns (string, uint256, uint256, bool, bool, uint256, uint256, bool, uint256, bool, address, uint256, uint256)', // Simplified view for struct mapping
    // We might need to access struct members individually if the auto-getter is complex, 
    // but standard mapping getter returns tuple of non-array members
]);

// Actually, for structs with arrays, the default getter only returns non-array fields.
// Let's use the exact signature generated by solidity for public mapping
const MAPPING_ABI = parseAbi([
    'function predictions(string) view returns (string id, uint256 target, uint256 deadline, bool resolved, bool result, uint256 totalYes, uint256 totalNo, bool isVoid, uint256 processedIndex, bool paidOut, address creator, uint256 seedYes, uint256 seedNo)'
]);

async function main() {
    console.log(`üîç Checking Prediction: ${PREDICTION_ID}`);

    const client = createPublicClient({
        chain: baseSepolia,
        transport: http('https://sepolia.base.org'),
    });

    try {
        const data = await client.readContract({
            address: CONTRACT_ADDRESS as `0x${string}`,
            abi: MAPPING_ABI,
            functionName: 'predictions',
            args: [PREDICTION_ID],
        });

        // Destructure based on ABI return order
        const [
            id, target, deadline, resolved, result,
            totalYes, totalNo, isVoid, processedIndex,
            paidOut, creator, seedYes, seedNo
        ] = data;

        console.log('\n--- üìä On-Chain State ---');
        console.log(`ID: ${id}`);
        console.log(`Resolved: ${resolved}`);
        console.log(`Result: ${result ? 'YES' : 'NO'}`);
        console.log(`PaidOut: ${paidOut}`);
        console.log(`Processed Index: ${processedIndex}`);
        console.log(`Total YES: ${totalYes.toString()}`);
        console.log(`Total NO: ${totalNo.toString()}`);
        console.log(`Is Void: ${isVoid}`);

        console.log('\n--- üß† Analysis ---');
        if (paidOut) {
            console.log('‚úÖ Contract says it is FULLY PAID OUT.');
        } else {
            console.log('‚ùå Contract says it is NOT paid out yet.');
        }

        if (resolved && !paidOut) {
            console.log('‚ö†Ô∏è  Resolved but not fully paid. Batch distribution needed.');
        }

    } catch (error) {
        console.error('Error reading contract:', error);
    }
}

main();
